# ScriptRunner Groovy Configuration Guide

## Overview
This document explains how to configure your Groovy code to be compatible with ScriptRunner's static type checking in Groovy 3.0.15.

## ScriptRunner Static Type Checking Issues

ScriptRunner uses Groovy's static type checking which is more strict than regular Groovy. The `.groovylintrc.json` file configures the external linter (npm-groovy-lint), but doesn't affect ScriptRunner's internal compiler.

## Common Static Type Checking Errors and Solutions

### 1. Cannot find matching method errors

**Issue**: When passing `null` or untyped variables to methods
```groovy
// Error: Cannot find matching method for Object parameter
def params = null
AuditFieldsUtil.setCreateAuditFields(params)  // Error!
```

**Solution**: Use proper type declarations
```groovy
// Correct: Explicitly type the variable
Map<String, Object> params = null
// Or handle null case
if (params != null) {
    AuditFieldsUtil.setCreateAuditFields(params as Map)
}
```

### 2. Cannot find method on Object type

**Issue**: Dynamic properties don't have known types
```groovy
params.created_by.length()  // Error: Object doesn't have length()
```

**Solution**: Cast to the expected type
```groovy
(params.created_by as String).length()
// Or use type-safe access
String createdBy = params.created_by
createdBy.length()
```

### 3. Method not found on dynamic types

**Issue**: Timestamp methods not recognized on dynamic properties
```groovy
params.updated_at.after(params.created_at)  // Error!
```

**Solution**: Cast to proper types
```groovy
(params.updated_at as Timestamp).after(params.created_at as Timestamp)
// Or use typed variables
Timestamp updatedAt = params.updated_at
Timestamp createdAt = params.created_at
updatedAt.after(createdAt)
```

## Recommended Patterns for ScriptRunner

### 1. Use Type Declarations

```groovy
// Instead of:
def params = [:]

// Use:
Map<String, Object> params = [:]
```

### 2. Cast When Necessary

```groovy
// Following ADR-031 standards:
UUID migrationId = UUID.fromString(filters.migrationId as String)
Integer teamId = Integer.parseInt(filters.teamId as String)
```

### 3. Handle Null Cases Explicitly

```groovy
if (params != null && params instanceof Map) {
    AuditFieldsUtil.setCreateAuditFields(params as Map)
}
```

### 4. For Test Files

Add annotation to disable static type checking for tests:
```groovy
import groovy.transform.TypeCheckingMode
import groovy.transform.CompileStatic

@CompileStatic(TypeCheckingMode.SKIP)
class AuditFieldsUtilTest {
    // Test methods here
}
```

Or selectively for specific methods:
```groovy
@CompileStatic(TypeCheckingMode.SKIP)
boolean testNullParameterMap() {
    // Test implementation
}
```

## Project-Specific Configuration

### For UMIG Project

1. **API Endpoints**: Already follow type safety (see ADR-031)
2. **Repositories**: Use explicit type casting
3. **Test Files**: Consider adding `@CompileStatic(TypeCheckingMode.SKIP)` annotation
4. **Utilities**: Ensure proper type declarations for parameters

### Groovy Compiler Options

If you have access to ScriptRunner's compiler configuration, you can add:
```groovy
// In ScriptRunner configuration (if available)
compilerConfiguration.addCompilationCustomizers(
    new ASTTransformationCustomizer(
        CompileStatic,
        extensions: ['groovy.transform.TypeCheckingMode.SKIP']
    )
)
```

## .groovylintrc.json Configuration

The `.groovylintrc.json` file has been configured for ScriptRunner compatibility with:
- Disabled CompileStatic and TypeChecked rules
- Proper naming conventions for ScriptRunner patterns
- Method size limits appropriate for REST endpoints
- Test-specific rule overrides

## Summary

1. **External Linting**: Configured via `.groovylintrc.json` (âœ… Complete)
2. **ScriptRunner Type Checking**: Requires code changes or annotations
3. **Recommended**: Add type annotations to test files to skip static checking
4. **Best Practice**: Follow ADR-031 type safety patterns throughout the codebase