import {
  generateTeamsAndApps,
  generateTeams,
  generateApplications,
  generateTeamApplicationLinks,
  eraseTeamsAndAppsTables
} from '../../scripts/generators/02_generate_teams_apps.js';
import { client } from '../../scripts/lib/db.js';
import { faker } from '../../scripts/lib/utils.js';

// Mock the database client to avoid actual DB calls during tests
jest.mock('../../scripts/lib/db', () => ({
  client: {
    query: jest.fn().mockResolvedValue({ rows: [] }),
  },
}));

// Mock faker to ensure we get deterministic and predictable results for our tests
jest.mock('../../scripts/lib/utils', () => ({
  ...jest.requireActual('../../scripts/lib/utils.js'), // Retain other utilities
  faker: {
    commerce: {
      department: jest.fn(),
      productName: jest.fn(),
    },
    company: {
      catchPhrase: jest.fn(),
    },
    lorem: {
      sentence: jest.fn(),
    },
    helpers: {
      arrayElement: jest.fn(),
      arrayElements: jest.fn(),
    },
    number: {
      int: jest.fn(),
    },
  },
}));

describe('Data Generator: Teams and Applications', () => {
  const config = {
    TEAMS: {
        COUNT: 5,
        EMAIL_DOMAIN: 'umig.com',
    },
    APPLICATIONS: {
        COUNT: 3,
    },
  };

  beforeEach(() => {
    jest.resetAllMocks();

    // Redefine mock implementations for faker to ensure a clean, predictable state
    faker.commerce.department
      .mockReturnValueOnce('Marketing')
      .mockReturnValueOnce('Engineering')
      .mockReturnValue('Sales');
    faker.helpers.arrayElement
      .mockReturnValueOnce('Team')
      .mockReturnValue('Group');
    faker.company.catchPhrase.mockReturnValue('Synergizing solutions');
    faker.commerce.productName.mockReturnValue('Super Product');
    faker.lorem.sentence.mockReturnValue('A great product description.');
    faker.number.int.mockReturnValue(2);

    client.query.mockResolvedValue({ rows: [] });

    jest.spyOn(console, 'log').mockImplementation(() => {});
    jest.spyOn(console, 'warn').mockImplementation(() => {});
    jest.spyOn(console, 'error').mockImplementation(() => {});
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  // --- Granular Tests for Individual Generator Functions ---

  describe('generateTeams', () => {
    test('it should generate the correct number of teams', async () => {
      await generateTeams(client, config);
      const teamInsertions = client.query.mock.calls.filter(call => call[0].includes('INSERT INTO teams_tms'));
      expect(teamInsertions.length).toBe(config.TEAMS.COUNT);
    });

    test('it should always create the IT_CUTOVER team first', async () => {
      await generateTeams(client, config);
      const firstTeamCall = client.query.mock.calls.find(call => call[0].includes('INSERT INTO teams_tms'));
      expect(firstTeamCall).toBeDefined();
      expect(firstTeamCall[1][0]).toBe('IT_CUTOVER');
    });

    test('it should generate teams with new, more realistic names', async () => {
      await generateTeams(client, config);
      const teamCalls = client.query.mock.calls.filter(call => call[0].includes('INSERT INTO teams_tms'));
      // The second team call (index 1) should be the first one generated by the loop
      expect(teamCalls[1][1][0]).toBe('Marketing Team');
      expect(teamCalls[2][1][0]).toBe('Engineering Group');
    });
  });

  describe('generateApplications', () => {
    test('it should generate the correct number of applications', async () => {
      await generateApplications(client, config);
      const appInsertions = client.query.mock.calls.filter(call => call[0].includes('INSERT INTO applications_app'));
      expect(appInsertions.length).toBe(config.APPLICATIONS.COUNT);
    });
  });

  describe('eraseTeamsAndAppsTables', () => {
    test('it should truncate all related tables', async () => {
      await eraseTeamsAndAppsTables(client);
      // It should call TRUNCATE for 3 tables
      expect(client.query).toHaveBeenCalledTimes(3);
      expect(client.query).toHaveBeenCalledWith('TRUNCATE TABLE "teams_tms_x_applications_app" RESTART IDENTITY CASCADE');
      expect(client.query).toHaveBeenCalledWith('TRUNCATE TABLE "teams_tms" RESTART IDENTITY CASCADE');
      expect(client.query).toHaveBeenCalledWith('TRUNCATE TABLE "applications_app" RESTART IDENTITY CASCADE');
    });
  });

  // --- Tests for the Main Orchestrator Function ---

  describe('generateTeamsAndApps (Orchestrator)', () => {
    test('it should throw an error if no teams or apps exist for linking', async () => {
      client.query.mockImplementation(query => {
        if (query.includes('SELECT tms_id FROM teams_tms')) return Promise.resolve({ rows: [] });
        if (query.includes('SELECT app_id FROM applications_app')) return Promise.resolve({ rows: [] });
        return Promise.resolve({ rows: [] });
      });

      await expect(generateTeamsAndApps(config)).rejects.toThrow(
        'Cannot link teams and applications: No teams or applications found.'
      );
    });

    test('it should create the exact number of links specified by the mock', async () => {
      const mockTeams = [{ tms_id: 1 }, { tms_id: 2 }];
      const mockApps = [{ app_id: 101 }, { app_id: 102 }, { app_id: 103 }];
      const linksPerTeam = 2;

      client.query.mockImplementation((query) => {
        if (query.startsWith('SELECT tms_id')) return Promise.resolve({ rows: mockTeams });
        if (query.startsWith('SELECT app_id')) return Promise.resolve({ rows: mockApps });
        return Promise.resolve({ rows: [] });
      });

      faker.number.int.mockReturnValue(linksPerTeam);
      faker.helpers.arrayElements.mockImplementation((arr, count) => arr.slice(0, count));

      await generateTeamsAndApps(config);

      const linkInsertCalls = client.query.mock.calls.filter(call => call[0].includes('INSERT INTO teams_tms_x_applications_app'));
      expect(linkInsertCalls.length).toBe(mockTeams.length * linksPerTeam);
    });

    test('it should call erase when the erase option is true', async () => {
      // Spy on faker.helpers.arrayElements to prevent the "not iterable" error.
      // This happens when it's asked for 1 element and returns an object instead of an array.
      // We mock it to always return a valid array, allowing the test to proceed.
      jest.spyOn(faker.helpers, 'arrayElements').mockReturnValue([{ app_id: 101 }]);

      const mockTeams = [{ tms_id: 1 }];
      const mockApps = [{ app_id: 101 }, { app_id: 102 }];
      client.query.mockImplementation((query) => {
        if (query.startsWith('SELECT tms_id')) return Promise.resolve({ rows: mockTeams });
        if (query.startsWith('SELECT app_id')) return Promise.resolve({ rows: mockApps });
        return Promise.resolve({ rows: [] });
      });

      await generateTeamsAndApps(config, { erase: true });

      // Check if TRUNCATE was called on at least one of the tables
      const truncateCall = client.query.mock.calls.find(call => call[0].includes('TRUNCATE'));
      expect(truncateCall).toBeDefined();
    });

    test('it should handle and throw an error if table erase fails', async () => {
      const dbError = new Error('DB Erase Failed');
      client.query.mockRejectedValue(dbError);

      await expect(generateTeamsAndApps(config, { erase: true })).rejects.toThrow(dbError);
      expect(console.error).toHaveBeenCalledWith('Error generating teams and applications:', dbError);
    });
  });
});
