const {
  generateTeamsAndApps,
  generateTeams,
  generateApplications,
  generateTeamApplicationLinks,
  resetTeamsAndAppsTables
} = require('../../generators/02_generate_teams_apps');
const { client } = require('../../lib/db');
const { faker } = require('../../lib/utils');

// Mock the database client to avoid actual DB calls during tests
jest.mock('../../lib/db', () => ({
  client: {
    query: jest.fn().mockResolvedValue({ rows: [] }),
  },
}));

// Mock faker to ensure we get deterministic and predictable results for our tests
jest.mock('../../lib/utils', () => ({
  ...jest.requireActual('../../lib/utils'), // Retain other utilities
  faker: {
    commerce: {
      department: jest.fn(),
      productName: jest.fn(),
    },
    company: {
      catchPhrase: jest.fn(),
    },
    lorem: {
      sentence: jest.fn(),
    },
    helpers: {
      arrayElement: jest.fn(),
    },
    number: {
      int: jest.fn(),
    },
  },
}));

describe('Data Generator: Teams and Applications', () => {
  const config = {
    TEAMS: {
        COUNT: 5,
        EMAIL_DOMAIN: 'umig.com',
    },
    APPLICATIONS: {
        COUNT: 3,
    },
  };

  beforeEach(() => {
    jest.resetAllMocks();

    // Redefine mock implementations for faker to ensure a clean, predictable state
    faker.commerce.department
      .mockReturnValueOnce('Marketing')
      .mockReturnValueOnce('Engineering')
      .mockReturnValue('Sales');
    faker.helpers.arrayElement
      .mockReturnValueOnce('Team')
      .mockReturnValue('Group');
    faker.company.catchPhrase.mockReturnValue('Synergizing solutions');
    faker.commerce.productName.mockReturnValue('Super Product');
    faker.lorem.sentence.mockReturnValue('A great product description.');
    faker.number.int.mockReturnValue(2);

    client.query.mockResolvedValue({ rows: [] });

    jest.spyOn(console, 'log').mockImplementation(() => {});
    jest.spyOn(console, 'warn').mockImplementation(() => {});
    jest.spyOn(console, 'error').mockImplementation(() => {});
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  // --- Granular Tests for Individual Generator Functions ---

  describe('generateTeams', () => {
    test('it should generate the correct number of teams', async () => {
      await generateTeams(client, config);
      const teamInsertions = client.query.mock.calls.filter(call => call[0].includes('INSERT INTO teams_tms'));
      expect(teamInsertions.length).toBe(config.TEAMS.COUNT);
    });

    test('it should always create the IT_CUTOVER team first', async () => {
      await generateTeams(client, config);
      const firstTeamCall = client.query.mock.calls.find(call => call[0].includes('INSERT INTO teams_tms'));
      expect(firstTeamCall).toBeDefined();
      expect(firstTeamCall[1][0]).toBe('IT_CUTOVER');
    });

    test('it should generate teams with new, more realistic names', async () => {
      await generateTeams(client, config);
      const teamCalls = client.query.mock.calls.filter(call => call[0].includes('INSERT INTO teams_tms'));
      // The second team call (index 1) should be the first one generated by the loop
      expect(teamCalls[1][1][0]).toBe('Marketing Team');
      expect(teamCalls[2][1][0]).toBe('Engineering Group');
    });
  });

  describe('generateApplications', () => {
    test('it should generate the correct number of applications', async () => {
      await generateApplications(client, config);
      const appInsertions = client.query.mock.calls.filter(call => call[0].includes('INSERT INTO applications_app'));
      expect(appInsertions.length).toBe(config.APPLICATIONS.COUNT);
    });
  });

  // --- Tests for the Main Orchestrator Function ---

  describe('generateTeamsAndApps (Orchestrator)', () => {
    test('it should throw an error if no teams or apps exist for linking', async () => {
      client.query.mockImplementation(query => {
        if (query.includes('SELECT tms_id FROM teams_tms')) return Promise.resolve({ rows: [] });
        if (query.includes('SELECT app_id FROM applications_app')) return Promise.resolve({ rows: [] });
        return Promise.resolve({ rows: [] });
      });

      await expect(generateTeamsAndApps(config)).rejects.toThrow(
        'Cannot link teams and applications: No teams or applications found.'
      );
    });

    test('it should create the exact number of links specified by the mock', async () => {
      const mockTeams = [{ tms_id: 1 }, { tms_id: 2 }];
      const mockApps = [{ app_id: 101 }, { app_id: 102 }, { app_id: 103 }];
      const linksPerTeam = 2;

      client.query.mockImplementation((query) => {
        if (query.startsWith('SELECT tms_id')) return Promise.resolve({ rows: mockTeams });
        if (query.startsWith('SELECT app_id')) return Promise.resolve({ rows: mockApps });
        return Promise.resolve({ rows: [] });
      });

      faker.number.int.mockReturnValue(linksPerTeam);

      await generateTeamsAndApps(config);

      const linkInsertCalls = client.query.mock.calls.filter(call => call[0].includes('INSERT INTO teams_tms_x_applications_app'));
      expect(linkInsertCalls.length).toBe(mockTeams.length * linksPerTeam);
    });

    test('it should handle and throw an error if table reset fails', async () => {
      const dbError = new Error('DB Reset Failed');
      client.query.mockRejectedValue(dbError);
      const errorSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

      await expect(generateTeamsAndApps(config, { reset: true })).rejects.toThrow(dbError);
      expect(errorSpy).toHaveBeenCalledWith('Error generating teams and applications:', dbError);
    });
  });
});
