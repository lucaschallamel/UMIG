package umig.tests.unit.repository

import groovy.sql.GroovyRowResult
import groovy.sql.Sql
import groovy.transform.CompileStatic
import groovy.transform.Field
import java.sql.Connection
import java.sql.SQLException
import java.sql.Timestamp

/**
 * Comprehensive test suite for TeamRepository following TD-001 self-contained architecture
 *
 * TD-013 Phase 2: Authentication Repository Coverage
 * - Tests team CRUD operations and authentication patterns
 * - ADR-031 compliant type casting
 * - Zero external dependencies
 *
 * Coverage: TeamRepository authentication and team management
 */
@CompileStatic
class TeamRepositoryComprehensiveTest {

    // ============================================
    // EMBEDDED DEPENDENCIES - TD-001 Pattern
    // ============================================

    static class MockConnection implements Connection {
        @Override
        void close() {}

        @Override
        boolean isClosed() { return false }

        @Override
        boolean getAutoCommit() { return true }

        @Override
        void setAutoCommit(boolean autoCommit) {}

        // Required stub methods
        @Override
        java.sql.Statement createStatement() { return null }

        @Override
        java.sql.PreparedStatement prepareStatement(String sql) { return null }

        @Override
        java.sql.CallableStatement prepareCall(String sql) { return null }

        @Override
        String nativeSQL(String sql) { return sql }

        @Override
        void commit() {}

        @Override
        void rollback() {}

        @Override
        java.sql.DatabaseMetaData getMetaData() { return null }

        @Override
        void setReadOnly(boolean readOnly) {}

        @Override
        boolean isReadOnly() { return false }

        @Override
        void setCatalog(String catalog) {}

        @Override
        String getCatalog() { return null }

        @Override
        void setTransactionIsolation(int level) {}

        @Override
        int getTransactionIsolation() { return 0 }

        @Override
        java.sql.SQLWarning getWarnings() { return null }

        @Override
        void clearWarnings() {}

        @Override
        java.sql.Statement createStatement(int resultSetType, int resultSetConcurrency) { return null }

        @Override
        java.sql.PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) { return null }

        @Override
        java.sql.CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) { return null }

        @Override
        java.util.Map<String, Class<?>> getTypeMap() { return null }

        @Override
        void setTypeMap(java.util.Map<String, Class<?>> map) {}

        @Override
        void setHoldability(int holdability) {}

        @Override
        int getHoldability() { return 0 }

        @Override
        java.sql.Savepoint setSavepoint() { return null }

        @Override
        java.sql.Savepoint setSavepoint(String name) { return null }

        @Override
        void rollback(java.sql.Savepoint savepoint) {}

        @Override
        void releaseSavepoint(java.sql.Savepoint savepoint) {}

        @Override
        java.sql.Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) { return null }

        @Override
        java.sql.PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) { return null }

        @Override
        java.sql.CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) { return null }

        @Override
        java.sql.PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) { return null }

        @Override
        java.sql.PreparedStatement prepareStatement(String sql, int[] columnIndexes) { return null }

        @Override
        java.sql.PreparedStatement prepareStatement(String sql, String[] columnNames) { return null }

        @Override
        java.sql.Clob createClob() { return null }

        @Override
        java.sql.Blob createBlob() { return null }

        @Override
        java.sql.NClob createNClob() { return null }

        @Override
        java.sql.SQLXML createSQLXML() { return null }

        @Override
        boolean isValid(int timeout) { return true }

        @Override
        void setClientInfo(String name, String value) {}

        @Override
        void setClientInfo(java.util.Properties properties) {}

        @Override
        String getClientInfo(String name) { return null }

        @Override
        java.util.Properties getClientInfo() { return null }

        @Override
        java.sql.Array createArrayOf(String typeName, Object[] elements) { return null }

        @Override
        java.sql.Struct createStruct(String typeName, Object[] attributes) { return null }

        @Override
        void setSchema(String schema) {}

        @Override
        String getSchema() { return null }

        @Override
        void abort(java.util.concurrent.Executor executor) {}

        @Override
        void setNetworkTimeout(java.util.concurrent.Executor executor, int milliseconds) {}

        @Override
        int getNetworkTimeout() { return 0 }

        @Override
        <T> T unwrap(Class<T> iface) { return null }

        @Override
        boolean isWrapperFor(Class<?> iface) { return false }
    }

    static class EmbeddedMockSql extends Sql {
        private Map<String, List<Map<String, Object>>> mockData = [:]
        private boolean throwError = false
        private String errorMessage = ""

        EmbeddedMockSql() {
            super(new MockConnection())
            initializeMockData()
        }

        private void initializeMockData() {
            mockData['teams'] = [
                [
                    tms_id: 101,
                    tms_code: 'DEV001',
                    tms_name: 'Development Team',
                    tms_description: 'Core development team',
                    tms_is_active: true,
                    tms_contact_email: 'dev@company.com',
                    created_date: new Timestamp(System.currentTimeMillis()),
                    created_by: 'admin'
                ] as Map<String, Object>,
                [
                    tms_id: 102,
                    tms_code: 'OPS001',
                    tms_name: 'Operations Team',
                    tms_description: 'Infrastructure and operations',
                    tms_is_active: true,
                    tms_contact_email: 'ops@company.com',
                    created_date: new Timestamp(System.currentTimeMillis()),
                    created_by: 'admin'
                ] as Map<String, Object>
            ]

            mockData['team_members'] = [
                [
                    tmm_id: 1,
                    tms_id: 101,
                    usr_id: 'user1',
                    tmm_role: 'Lead',
                    tmm_is_active: true
                ] as Map<String, Object>,
                [
                    tmm_id: 2,
                    tms_id: 101,
                    usr_id: 'user2',
                    tmm_role: 'Member',
                    tmm_is_active: true
                ] as Map<String, Object>
            ]
        }

        @Override
        List<GroovyRowResult> rows(String query, List<Object> params = []) {
            if (throwError) {
                throw new SQLException(errorMessage)
            }

            // Team queries
            if (query.contains('SELECT * FROM team_master WHERE tms_id = ?')) {
                Integer teamId = params[0] as Integer
                return mockData['teams'].findAll {
                    (it as Map<String, Object>).tms_id == teamId
                }.collect { new GroovyRowResult(it as Map) }
            }

            if (query.contains('SELECT * FROM team_master WHERE tms_code = ?')) {
                String teamCode = params[0] as String
                return mockData['teams'].findAll {
                    (it as Map<String, Object>).tms_code == teamCode
                }.collect { new GroovyRowResult(it as Map) }
            }

            if (query.contains('SELECT * FROM team_members WHERE tms_id = ?')) {
                Integer teamId = params[0] as Integer
                return mockData['team_members'].findAll {
                    (it as Map<String, Object>).tms_id == teamId
                }.collect { new GroovyRowResult(it as Map) }
            }

            // All active teams
            if (query.contains('SELECT * FROM team_master WHERE tms_is_active = true')) {
                return mockData['teams'].findAll {
                    (it as Map<String, Object>).tms_is_active == true
                }.collect { new GroovyRowResult(it as Map) }
            }

            return []
        }

        GroovyRowResult firstRow(String query, List<Object> params = []) {
            List<GroovyRowResult> results = rows(query, params)
            return results.isEmpty() ? null : results[0]
        }

        @Override
        boolean execute(String query, List<Object> params = []) {
            if (throwError) {
                throw new SQLException(errorMessage)
            }

            if (query.contains('INSERT INTO team_master')) {
                return true
            }

            if (query.contains('UPDATE team_master')) {
                return true
            }

            if (query.contains('DELETE FROM team_master')) {
                if (params[0] == 999) { // Non-existent team
                    return false
                }
                if (params[0] == 101) { // Team with dependencies
                    throw new SQLException("Cannot delete team with active members", "23503")
                }
                return true
            }

            return true
        }

        void setError(boolean error, String message = "Test error") {
            this.throwError = error
            this.errorMessage = message
        }
    }

    static class EmbeddedDatabaseUtil {
        private static EmbeddedMockSql mockSql = new EmbeddedMockSql()

        static <T> T withSql(Closure<T> closure) {
            return closure.call(mockSql) as T
        }

        static void resetMockSql() {
            mockSql = new EmbeddedMockSql()
        }

        static EmbeddedMockSql getMockSql() {
            return mockSql
        }
    }

    static class EmbeddedTeamRepository {

        Map<String, Object> findTeamById(Integer teamId) {
            return EmbeddedDatabaseUtil.withSql { sql ->
                String query = "SELECT * FROM team_master WHERE tms_id = ?"
                GroovyRowResult result = (sql as EmbeddedMockSql).firstRow(query, [teamId] as List<Object>)
                return result ? (result as Map<String, Object>) : null
            } as Map<String, Object>
        }

        Map<String, Object> findTeamByCode(String teamCode) {
            return EmbeddedDatabaseUtil.withSql { sql ->
                String query = "SELECT * FROM team_master WHERE tms_code = ?"
                GroovyRowResult result = (sql as EmbeddedMockSql).firstRow(query, [teamCode] as List<Object>)
                return result ? (result as Map<String, Object>) : null
            } as Map<String, Object>
        }

        List<Map<String, Object>> findAllActiveTeams() {
            return EmbeddedDatabaseUtil.withSql { sql ->
                String query = "SELECT * FROM team_master WHERE tms_is_active = true"
                List<GroovyRowResult> results = (sql as EmbeddedMockSql).rows(query)
                return results.collect { it as Map<String, Object> }
            }
        }

        List<Map<String, Object>> findTeamMembers(Integer teamId) {
            return EmbeddedDatabaseUtil.withSql { sql ->
                String query = "SELECT * FROM team_members WHERE tms_id = ?"
                List<GroovyRowResult> results = (sql as EmbeddedMockSql).rows(query, [teamId] as List<Object>)
                return results.collect { it as Map<String, Object> }
            }
        }

        Map<String, Object> createTeam(Map<String, Object> teamData) {
            // Validation
            List<String> requiredFields = ['tms_code', 'tms_name']
            List<String> missingFields = requiredFields.findAll { !(teamData.containsKey(it)) }

            if (!missingFields.isEmpty()) {
                return [
                    success: false,
                    error: "Missing required fields: ${missingFields.join(', ')}"
                ] as Map<String, Object>
            }

            // Check for duplicate code
            Map<String, Object> existing = findTeamByCode(teamData.tms_code as String)
            if (existing != null) {
                return [
                    success: false,
                    error: "Team code already exists: ${teamData.tms_code}"
                ] as Map<String, Object>
            }

            return EmbeddedDatabaseUtil.withSql { sql ->
                try {
                    boolean result = (sql as EmbeddedMockSql).execute("INSERT INTO team_master", [])
                    if (result) {
                        return [
                            success: true,
                            data: (teamData + ([tms_id: 103] as Map<String, Object>)),
                            id: 103
                        ] as Map<String, Object>
                    }
                    return [success: false, error: "Insert failed"] as Map<String, Object>
                } catch (SQLException e) {
                    return [success: false, error: e.message] as Map<String, Object>
                }
            }
        }

        Map<String, Object> updateTeam(Integer teamId, Map<String, Object> updates) {
            Map<String, Object> existing = findTeamById(teamId)
            if (existing == null) {
                return [
                    success: false,
                    error: "Team not found: ${teamId}"
                ] as Map<String, Object>
            }

            return EmbeddedDatabaseUtil.withSql { sql ->
                try {
                    boolean result = (sql as EmbeddedMockSql).execute("UPDATE team_master", [teamId] as List<Object>)
                    return [
                        success: result,
                        data: updates,
                        id: teamId
                    ] as Map<String, Object>
                } catch (SQLException e) {
                    return [success: false, error: e.message] as Map<String, Object>
                }
            }
        }

        Map<String, Object> deleteTeam(Integer teamId) {
            return EmbeddedDatabaseUtil.withSql { sql ->
                try {
                    boolean result = (sql as EmbeddedMockSql).execute("DELETE FROM team_master", [teamId] as List<Object>)
                    return [
                        success: result,
                        deleted: result,
                        id: teamId
                    ] as Map<String, Object>
                } catch (SQLException e) {
                    if (e.SQLState == "23503") {
                        return [
                            success: false,
                            error: "Cannot delete team with active members"
                        ] as Map<String, Object>
                    }
                    return [success: false, error: e.message] as Map<String, Object>
                }
            }
        }

        boolean isUserInTeam(String userId, Integer teamId) {
            List<Map<String, Object>> members = findTeamMembers(teamId)
            return members.any { (it.usr_id as String) == userId }
        }

        String getUserTeamRole(String userId, Integer teamId) {
            List<Map<String, Object>> members = findTeamMembers(teamId)
            Map<String, Object> member = members.find { (it.usr_id as String) == userId }
            return member ? (member.tmm_role as String) : null
        }
    }

    // ============================================
    // TEST EXECUTION
    // ============================================

    static int testCount = 0
    static int passCount = 0
    static List<String> failures = []
    static long startTime = System.currentTimeMillis()

    static void main(String[] args) {
        println "\n" + "="*80
        println "TD-013 Phase 2: TeamRepository Comprehensive Test Suite"
        println "="*80

        // Test Categories
        testTeamCRUD()
        testTeamQueries()
        testTeamMembers()
        testAuthentication()
        testErrorHandling()

        // Print Results
        printTestSummary()
    }

    static void testTeamCRUD() {
        println "\n📋 Testing Team CRUD Operations..."
        EmbeddedTeamRepository repository = new EmbeddedTeamRepository()

        // Test 1: Find team by ID
        runTest("Find team by ID") {
            Map<String, Object> team = repository.findTeamById(101)
            assert team != null : "Should find team"
            assert team.tms_id == 101 : "Should have correct ID"
            assert team.tms_name == 'Development Team' : "Should have correct name"
        }

        // Test 2: Find team by code
        runTest("Find team by code") {
            Map<String, Object> team = repository.findTeamByCode('DEV001')
            assert team != null : "Should find team"
            assert team.tms_code == 'DEV001' : "Should have correct code"
            assert team.tms_name == 'Development Team' : "Should have correct name"
        }

        // Test 3: Create new team
        runTest("Create new team") {
            Map<String, Object> teamData = [
                tms_code: 'QA001',
                tms_name: 'QA Team',
                tms_description: 'Quality Assurance Team',
                tms_contact_email: 'qa@company.com'
            ] as Map<String, Object>

            Map<String, Object> result = repository.createTeam(teamData)
            assert result.success == true : "Should succeed"
            assert result.id == 103 : "Should return new ID"
        }

        // Test 4: Create team with duplicate code
        runTest("Create team with duplicate code") {
            Map<String, Object> teamData = [
                tms_code: 'DEV001',
                tms_name: 'Another Dev Team'
            ] as Map<String, Object>

            Map<String, Object> result = repository.createTeam(teamData)
            assert result.success == false : "Should fail"
            assert (result.error as String).contains('already exists') : "Should indicate duplicate"
        }

        // Test 5: Update existing team
        runTest("Update existing team") {
            Map<String, Object> updates = [
                tms_name: 'Updated Dev Team',
                tms_description: 'Updated description'
            ] as Map<String, Object>

            Map<String, Object> result = repository.updateTeam(101, updates)
            assert result.success == true : "Should succeed"
            assert result.id == 101 : "Should return team ID"
        }

        // Test 6: Update non-existent team
        runTest("Update non-existent team") {
            Map<String, Object> updates = [tms_name: 'Updated'] as Map<String, Object>
            Map<String, Object> result = repository.updateTeam(999, updates)
            assert result.success == false : "Should fail"
            assert (result.error as String).contains('not found') : "Should indicate not found"
        }

        // Test 7: Delete team without dependencies
        runTest("Delete team without dependencies") {
            Map<String, Object> result = repository.deleteTeam(102)
            assert result.success == true : "Should succeed"
            assert result.deleted == true : "Should indicate deletion"
        }

        // Test 8: Delete team with dependencies
        runTest("Delete team with dependencies") {
            Map<String, Object> result = repository.deleteTeam(101)
            assert result.success == false : "Should fail"
            assert (result.error as String).contains('active members') : "Should indicate constraint"
        }
    }

    static void testTeamQueries() {
        println "\n🔍 Testing Team Queries..."
        EmbeddedTeamRepository repository = new EmbeddedTeamRepository()

        // Test 1: Find all active teams
        runTest("Find all active teams") {
            List<Map<String, Object>> teams = repository.findAllActiveTeams()
            assert teams != null : "Should return teams"
            assert teams.size() == 2 : "Should find 2 active teams"
            assert teams.every { (it.tms_is_active as Boolean) == true } : "All should be active"
        }

        // Test 2: Find non-existent team
        runTest("Find non-existent team") {
            Map<String, Object> team = repository.findTeamById(999)
            assert team == null : "Should return null for non-existent team"
        }

        // Test 3: Find team with null ID
        runTest("Find team with null ID") {
            Map<String, Object> team = repository.findTeamById(null)
            assert team == null : "Should handle null ID gracefully"
        }
    }

    static void testTeamMembers() {
        println "\n👥 Testing Team Members..."
        EmbeddedTeamRepository repository = new EmbeddedTeamRepository()

        // Test 1: Find team members
        runTest("Find team members") {
            List<Map<String, Object>> members = repository.findTeamMembers(101)
            assert members != null : "Should return members"
            assert members.size() == 2 : "Should find 2 members"
            assert members[0].usr_id == 'user1' : "Should have correct user"
            assert members[0].tmm_role == 'Lead' : "Should have correct role"
        }

        // Test 2: Check user in team
        runTest("Check user in team") {
            boolean inTeam = repository.isUserInTeam('user1', 101)
            assert inTeam == true : "User should be in team"

            boolean notInTeam = repository.isUserInTeam('user3', 101)
            assert notInTeam == false : "User should not be in team"
        }

        // Test 3: Get user team role
        runTest("Get user team role") {
            String role = repository.getUserTeamRole('user1', 101)
            assert role == 'Lead' : "Should return Lead role"

            String noRole = repository.getUserTeamRole('user3', 101)
            assert noRole == null : "Should return null for non-member"
        }

        // Test 4: Find members of empty team
        runTest("Find members of empty team") {
            List<Map<String, Object>> members = repository.findTeamMembers(102)
            assert members != null : "Should return empty list"
            assert members.isEmpty() : "Should have no members"
        }
    }

    static void testAuthentication() {
        println "\n🔐 Testing Authentication Patterns..."
        EmbeddedTeamRepository repository = new EmbeddedTeamRepository()

        // Test 1: Validate team access
        runTest("Validate team access") {
            // User with Lead role
            boolean hasAccess = repository.isUserInTeam('user1', 101)
            String role = repository.getUserTeamRole('user1', 101)
            assert hasAccess && role == 'Lead' : "Lead should have access"
        }

        // Test 2: Validate team permissions
        runTest("Validate team permissions") {
            String userRole = repository.getUserTeamRole('user2', 101)
            assert userRole == 'Member' : "Should have Member role"

            // Check permission level based on role
            boolean canEdit = userRole == 'Lead'
            assert !canEdit : "Member should not have edit permission"
        }

        // Test 3: Cross-team access check
        runTest("Cross-team access check") {
            boolean team1Access = repository.isUserInTeam('user1', 101)
            boolean team2Access = repository.isUserInTeam('user1', 102)
            assert team1Access == true : "Should have team 1 access"
            assert team2Access == false : "Should not have team 2 access"
        }
    }

    static void testErrorHandling() {
        println "\n⚠️ Testing Error Handling..."
        EmbeddedTeamRepository repository = new EmbeddedTeamRepository()
        EmbeddedMockSql mockSql = EmbeddedDatabaseUtil.getMockSql()

        // Test 1: Database connection error
        runTest("Handle database connection error") {
            mockSql.setError(true, "Connection refused")
            try {
                repository.findTeamById(101)
                assert false : "Should throw exception"
            } catch (SQLException e) {
                assert e.message == "Connection refused" : "Should propagate error"
            } finally {
                mockSql.setError(false)
            }
        }

        // Test 2: Missing required fields
        runTest("Handle missing required fields") {
            Map<String, Object> teamData = [
                tms_description: 'Missing required fields'
            ] as Map<String, Object>

            Map<String, Object> result = repository.createTeam(teamData)
            assert result.success == false : "Should fail"
            assert (result.error as String).contains('Missing required fields') : "Should indicate missing fields"
        }

        // Test 3: Constraint violation
        runTest("Handle constraint violation") {
            Map<String, Object> result = repository.deleteTeam(101)
            assert result.success == false : "Should fail"
            assert (result.error as String).contains('active members') : "Should indicate constraint violation"
        }
    }

    // ============================================
    // TEST UTILITIES
    // ============================================

    static void runTest(String testName, Closure test) {
        testCount++
        try {
            test.call()
            passCount++
            println "  ✅ ${testName}"
        } catch (AssertionError e) {
            failures.add("${testName}: ${e.message}" as String)
            println "  ❌ ${testName}: ${e.message}"
        } catch (Exception e) {
            failures.add("${testName}: Unexpected error - ${e.message}" as String)
            println "  ❌ ${testName}: Unexpected error - ${e.message}"
        }
    }

    static void printTestSummary() {
        long duration = System.currentTimeMillis() - startTime

        println "\n" + "="*80
        println "TEST EXECUTION SUMMARY"
        println "="*80
        println "Total Tests: ${testCount}"
        println "Passed: ${passCount}"
        println "Failed: ${failures.size()}"
        println "Success Rate: ${testCount > 0 ? (passCount * 100 / testCount) : 0}%"
        println "Execution Time: ${duration}ms"

        if (!failures.isEmpty()) {
            println "\n❌ FAILURES:"
            failures.each { println "  - ${it}" }
        } else {
            println "\n🎉 ALL TESTS PASSED! TD-013 Phase 2 TeamRepository coverage complete. 🚀"
        }

        println "\n📊 Performance Metrics:"
        println "  - Average test time: ${testCount > 0 ? duration / testCount : 0}ms"
        println "  - Tests per second: ${duration > 0 ? (testCount * 1000 / duration) : 0}"

        println "\n✨ Coverage Areas:"
        println "  ✓ Team CRUD Operations"
        println "  ✓ Team Query Operations"
        println "  ✓ Team Member Management"
        println "  ✓ Authentication Patterns"
        println "  ✓ Error Handling"

        println "="*80
    }
}