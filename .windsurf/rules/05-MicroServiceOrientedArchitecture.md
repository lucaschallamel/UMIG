---
trigger: always_on
---

*Scope: This document outlines the specific patterns and strategies for implementing our Microservice-Oriented Architecture, based on Chris Richardson's "Microservices Patterns". It builds upon the foundational principles in `04-TwelveFactorApp.md` and provides a detailed guide for service design, decomposition, communication, and data management.*

Observe the principles set by the book "Microservices Patterns" by Chris Richardson.

| Pattern Category                        | Key Principles and Patterns                                  |
| :-------------------------------------- | :----------------------------------------------------------- |
| **Application Architecture**            | ðŸ”¹ **Monolithic Architecture:** Structures an application as a single, unified deployable unit. Good for simple applications, but becomes "monolithic hell" as complexity grows. <br>ðŸ”¹ **Microservice Architecture:** Structures an application as a collection of small, autonomous, and loosely coupled services. This is the core pattern the rest of the book builds upon. |
| **Decomposition**                       | ðŸ”¹ **Decompose by Business Capability:** A strategy to define services based on what a business *does* (e.g., Order Management, Inventory Management). This creates stable service boundaries. <br>ðŸ”¹ **Decompose by Subdomain:** A Domain-Driven Design (DDD) approach to define services around specific problem subdomains. This aligns service boundaries with the business domain model. |
| **Inter-process Communication (IPC)**   | ðŸ”¹ **Remote Procedure Invocation (RPI):** A client invokes a service using a synchronous, request/response protocol like REST or gRPC. It's simple and familiar but creates tight coupling and can reduce availability. <br>ðŸ”¹ **Messaging:** Services communicate asynchronously by exchanging messages via a message broker. This promotes loose coupling and improves resilience. <br>ðŸ”¹ **Circuit Breaker:** A pattern to prevent a network or service failure from cascading. After a number of consecutive failures, the breaker trips, and further calls fail immediately, preventing the client from waiting for a service that's likely unavailable. <br>ðŸ”¹ **Service Discovery (Self/3rd party registration, Client/Server-side discovery):** Patterns for how a client service can find the network location of a service instance in a dynamic cloud environment. |
| **Data Consistency & Transactions**     | ðŸ”¹ **Database per Service:** Each microservice owns its own data and is solely responsible for it. This is fundamental to loose coupling but creates the need for new transaction management strategies. <br>ðŸ”¹ **Saga:** The master pattern for managing data consistency across services without using distributed transactions. It's a sequence of local transactions where each transaction updates data in one service and publishes an event/message that triggers the next local transaction in the saga. If a step fails, the saga executes compensating transactions to undo the preceding changes. <br>ðŸ”¹ **Transactional Outbox / Polling Publisher / Transaction Log Tailing:** These are patterns to reliably publish messages/events as part of a local database transaction, ensuring that messages are not lost if the service crashes after updating its database but before sending the message. |
| **Business Logic Design**               | ðŸ”¹ **Domain Model:** The classic object-oriented approach where you have classes with both state and behaviour. This is preferred for complex logic. <br>ðŸ”¹ **Transaction Script:** A procedural approach where a single procedure handles a single request. Simpler, but becomes unmanageable for complex business logic. <br>ðŸ”¹ **Aggregate (DDD):** A cluster of related domain objects that can be treated as a single unit. It has a root entity, and all external access must go through the root. A transaction should only ever create or update a single aggregate, which fits the microservice model perfectly. <br>ðŸ”¹ **Domain Events:** Aggregates publish events when their state changes. This is the foundation for event-driven architectures and is critical for sagas and data replication. <br>ðŸ”¹ **Event Sourcing:** A fundamentally different approach to persistence. Instead of storing the current state of an aggregate, you store the sequence of state-changing events. The current state is derived by replaying the events. This provides a guaranteed, reliable audit log and simplifies event publishing. |
| **Querying Data**                       | ðŸ”¹ **API Composition:** A client (or an API Gateway) retrieves data from multiple services and joins it in memory. Simple for basic queries but inefficient for complex joins, sorting, or filtering across large datasets. <br>ðŸ”¹ **Command Query Responsibility Segregation (CQRS):** The solution for complex queries. You maintain one or more denormalised, read-optimised "view" databases that are kept up-to-date by subscribing to events from the services that own the data. This separates the command-side (write) model from the query-side (read) model. |
| **External APIs**                       | ðŸ”¹ **API Gateway:** A single entry point for all external clients. It routes requests to the appropriate backend services, and can perform API composition to provide a coarse-grained API that's more efficient for clients. It can also handle cross-cutting concerns like authentication. <br>ðŸ”¹ **Backends for Frontends (BFF):** A variation of the API Gateway pattern where you have a separate, tailored API gateway for each specific client (e.g., one for the mobile app, one for the web app). |
| **Testing**                             | ðŸ”¹ **Consumer-Driven Contract Test:** A test written by the *consumer* of a service to verify that the *provider* meets its expectations. This ensures that services can communicate correctly without requiring slow, brittle end-to-end tests. <br>ðŸ”¹ **Service Component Test:** An acceptance test for a single service in isolation, using stubs for its external dependencies. |
| **Deployment & Cross-Cutting Concerns** | ðŸ”¹ **Service as a Container:** Package a service as a container image (e.g., Docker) to encapsulate its technology stack. <br>ðŸ”¹ **Serverless Deployment:** Deploy services using a platform like AWS Lambda that abstracts away the underlying infrastructure entirely. <br>ðŸ”¹ **Microservice Chassis:** A framework (like Spring Boot + Spring Cloud) that handles cross-cutting concerns such as externalised configuration, health checks, metrics, and distributed tracing, so developers can focus on business logic. <br>ðŸ”¹ **Service Mesh:** An infrastructure layer (like Istio or Linkerd) that handles inter-service communication concerns like circuit breakers, distributed tracing, and load balancing outside of the service code itself. |
| **Refactoring**                         | ðŸ”¹ **Strangler Application:** The strategy for migrating a monolith. You incrementally build a new application consisting of microservices *around* the monolith, gradually strangling it until it can be retired. Avoid a "big bang" rewrite at all costs. |

More at <https://microservices.io/patterns/>