{
  "enabled": true,
  "name": "Groovy REST API Workflow",
  "description": "Triggers the standard workflow for creating or modifying Groovy REST API endpoints, ensuring adherence to established patterns and preventing bugs through consistent implementation",
  "version": "1",
  "when": {
    "type": "userTriggered",
    "patterns": [
      "src/groovy/umig/api/**/*.groovy"
    ]
  },
  "then": {
    "type": "askAgent",
    "prompt": "A Groovy REST API file has been modified. Please follow the standard workflow for creating or modifying Groovy REST API endpoints in this project:\n\n## Key Reference Documents\n**PRIMARY REFERENCE**: `/docs/architecture/UMIG - TOGAF Phase C - Application Architecture.md` — Comprehensive API design and application architecture standards\n**ARCHITECTURE HUB**: `/docs/architecture/UMIG - TOGAF Phases A-D - Architecture Requirements Specification.md` — Navigation hub for 49 ADRs\n**SUPPORTING REFERENCES**:\n- Current ADRs in `/docs/architecture/adr/`\n- Working examples: `src/groovy/umig/api/v2/TeamsApi.groovy`\n\n## Standard Workflow Steps:\n\n1. **Analyze the Existing Pattern**:\n   * Before writing any code, thoroughly review a working, stable API file like `src/groovy/umig/api/v2/TeamsApi.groovy`.\n   * Pay close attention to the structure: separate endpoint definitions for each HTTP method, simple `try-catch` blocks for error handling, and standard `javax.ws.rs.core.Response` objects.\n\n2. **Replicate the Pattern**:\n   * Create a new endpoint definition for each HTTP method (`GET`, `POST`, `PUT`, `DELETE`).\n   * Do NOT use a central dispatcher, custom exception classes, or complex helper methods for error handling. Keep all logic within the endpoint method.\n\n3. **Implement Business Logic**:\n   * Write the core business logic inside a `try` block.\n   * Call the appropriate `UserRepository` or `TeamRepository` methods.\n\n4. **Handle Success Cases**:\n   * For `GET`, `POST`, and `PUT`, return a `Response.ok()` or `Response.status(Response.Status.CREATED)` with a `JsonBuilder` payload.\n   * **CRITICAL**: For a successful `DELETE`, always return `Response.noContent().build()`. Do NOT attempt to return a body.\n\n5. **Handle Error Cases**:\n   * Use `catch (SQLException e)` to handle specific database errors (e.g., foreign key violations `23503`, unique constraint violations `23505`).\n   * Use a generic `catch (Exception e)` for all other unexpected errors.\n   * In all `catch` blocks, log the error using `log.error()` or `log.warn()` and return an appropriate `Response.status(...)` with a simple JSON error message.\n\n6. **Validate Inputs**:\n   * Strictly validate all incoming data (path parameters, request bodies) at the beginning of the endpoint method.\n   * Return a `400 Bad Request` for any invalid input.\n\nThis workflow ensures all API development adheres to the project's established, stable patterns to prevent bugs and maintain consistency."
  }
}